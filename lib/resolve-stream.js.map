{"version":3,"sources":["../src/resolve-stream.js"],"names":[],"mappings":";;;;;kBAqBwB,a;;AArBxB;;;;AACA;;;;AACA;;;;AACA;;;;AAEA;;AACA;;;;;;;;;;;;;;;;;;;AAee,SAAS,aAAT,CAAuB,MAAvB,EAA+B,GAA/B,EAAoC;AACjD,MAAM,UAAU,iBAAE,KAAF,CAAQ,EAAR,EAAY,GAAZ,CAAhB;;;;AAIA,WAAS,OAAT,CAAiB,IAAjB,EAAuB,YAAvB,EAAqC,UAArC,EAAiD,OAAjD,EAA0D,MAA1D,EAAkE;AAChE,QAAM,iBAAiB,IAAI,aAAJ,CAAkB,IAAlB,EAAwB,OAAxB,CAAvB;;AAEA,aAAS,KAAT,CAAe,KAAf,EAAsB;AACpB,aAAO,iBAAE,KAAF,CACL,0BAAa,KAAb,EAAoB,OAApB,EAA6B,MAA7B,CADK,EAEL;AACE,gBAAQ,IADV;AAEE,kCAFF;AAGE,iDAAgB,UAAhB,EAHF;AAIE,kBAAU,IAAV,4BAAmB,OAAnB;AAJF,OAFK,CAAP;AASD;;AAED,aAAS,SAAT,CAAmB,KAAnB,EAA0B;AACxB,aAAO,8BAAiB,KAAjB,EAAwB,EAAE,cAAF,EAAU,QAAQ,IAAlB,EAAxB,CAAP;AACD;;AAED,QAAM,mBAAmB,EAAE,0CAAF,EAAsC,YAAtC,EAA6C,oBAA7C,EAAzB;AACA,QAAM,aAAa,iBAAE,GAAF,CAAM,OAAN,EAAe,YAAf,+BAAnB;AACA,QAAM,kBAAkB,qCAAgB,gBAAhB,EAAkC,UAAlC,CAAxB;;AAEA,oBAAgB,IAAhB,CAAqB,cAArB;;AAEA,WAAO,wBAAS,EAAE,YAAY,IAAd,EAAT,EAA+B,eAA/B,EAAgD,cAAhD,CAAP;AACD;;;AAGD,WAAS,SAAT,CAAmB,KAAnB,EAA0B,QAA1B,EAAoC,EAApC,EAAwC;AAAA;;AACtC,QAAM,mBAAmB,iBAAE,GAAF,CAAM,KAAN,EAAa,MAAb,CAAzB;AACA,QAAM,eAAe,iBAAE,GAAF,CAAM,KAAN,EAAa,cAAb,KAAgC,EAArD;AACA,QAAM,aAAa,iBAAE,GAAF,CAAM,KAAN,EAAa,YAAb,KAA8B,EAAjD;AACA,QAAM,UAAU,iBAAE,GAAF,CAAM,KAAN,EAAa,SAAb,KAA2B,EAA3C;AACA,QAAM,SAAS,iBAAE,GAAF,CAAM,KAAN,EAAa,QAAb,KAA0B,EAAzC;AACA,QAAM,OAAO,IAAb;;AAEA,aAAS,WAAT,CAAqB,OAArB,EAA8B,IAA9B,EAAoC,KAApC,EAA2C;AACzC,WAAK,IAAL,CAAU,KAAV;AACA,UAAI,CAAC,iBAAE,WAAF,CAAc,OAAd,CAAL,EAA6B,KAAK,IAAL,CAAU,OAAV,EAAmB,EAAE,gBAAF,EAAW,UAAX,EAAiB,YAAjB,EAAnB;AAC7B,aAAO,IAAP;AACD;;AAED,QAAI,CAAC,gBAAL,EAAuB,OAAO,aAAP;;;AAGvB,QAAM,SAAS;AACb,YAAM,iBAAE,GAAF,CAAM,KAAN,EAAa,MAAb,CADO;AAEb,cAAQ,iBAAE,GAAF,CAAM,KAAN,EAAa,QAAb,IAAyB,MAAM,OAAN,CAAc,OAAd,CAAsB,gBAAtB;AAFpB,KAAf;;;AAMA,kCAAgB,gBAAhB,EAAkC,YAAlC,EAAgD,MAAhD,EAAwD,MAAxD,EAAgE,UAAC,QAAD,EAAW,OAAX,EAAoB,QAApB,EAA8B,gBAA9B,EAAmD;AACjH,UAAI,QAAJ,EAAc,OAAO,YAAY,0BAAZ,EAAwC,gBAAxC,EAA0D,QAA1D,CAAP;;AAEd,UAAM,aAAa,iBAAE,IAAF,8BAAW,gBAAX,sBAAgC,UAAhC,GAAnB;;;AAGA,UAAM,OAAO,gCAAkB,OAAlB,EAA2B,QAA3B,EAAqC,UAArC,CAAb;;;AAGA,UAAM,eAAe,iBAAE,UAAF,CAAa,QAAQ,WAArB,IAAoC,QAAQ,WAA5C,uBAArB;;;AAGA,mBAAa,IAAb,EAAmB,UAAC,UAAD,EAAa,KAAb,EAAoB,YAApB,EAAkC,oBAAlC,EAA2D;AAC5E,YAAI,UAAJ,EAAgB,OAAO,YAAY,4BAAZ,EAA0C,YAA1C,EAAwD,UAAxD,CAAP;AAChB,YAAI,iBAAE,QAAF,CAAW,OAAX,EAAoB,YAApB,CAAJ,EAAuC,OAAO,YAAY,8BAAZ,EAA4C,YAA5C,CAAP;;AAEvC,YAAM,WAAW,QAAQ,YAAR,EAAsB,oBAAtB,EAA4C,UAA5C,EAAwD,OAAxD,EAAiE,MAAjE,CAAjB;;AAEA,cAAM,EAAN,CAAS,OAAT,EAAkB,UAAC,QAAD,EAAc;AAC9B,gBAAK,IAAL,CAAU,OAAV,EAAmB,QAAnB;AACA;AACD,SAHD;;AAKA,iBAAS,EAAT,CAAY,UAAZ,EAAwB,SAAS,aAAT,GAAyB;AAC/C,cAAI,gBAAJ;AACA,iBAAO,CAAC,UAAU,KAAK,IAAL,EAAX,MAA4B,IAAnC,EAAyC;AACvC,iBAAK,IAAL,CAAU,OAAV;AACD;AACF,SALD;;AAOA,iBAAS,EAAT,CAAY,OAAZ,EAAqB,UAAC,UAAD,EAAgB;AACnC,gBAAK,IAAL,CAAU,OAAV,EAAmB,UAAnB;AACA;AACD,SAHD;;AAKA,iBAAS,EAAT,CAAY,KAAZ,EAAmB;AAAA,iBAAM,IAAN;AAAA,SAAnB;;AAEA,cAAM,IAAN,CAAW,QAAX;AACD,OA1BD;AA2BD,KAvCD;AAwCD;;AAED,SAAO,kBAAS,GAAT,CAAa,SAAb,CAAP;AACD","file":"resolve-stream.js","sourcesContent":["import _ from 'lodash';\nimport through2 from 'through2';\nimport duplexer from 'duplexer2';\nimport regexpTokenizer from 'regexp-stream-tokenizer';\n\nimport { parseTransclude, resolveReferences, resolveLink } from './resolve';\nimport { defaultTokenRegExp, defaultToken, defaultSeparator, WHITESPACE_GROUP } from './config';\n\n/**\n* Input stream: object\n* - link (string, required)\n* - relativePath (string, required)\n* - parents (array, required)\n* - references (array, required)\n*\n* Output stream: object\n* - chunk (string, required)\n*\n* Input and output properties can be altered by providing options\n*/\n\nexport default function ResolveStream(source, opt) {\n  const options = _.merge({}, opt);\n\n  // Create nested duplex stream\n  // TODO: rename this function for improved clarity\n  function inflate(link, relativePath, references, parents, indent) {\n    const resolverStream = new ResolveStream(link, options);\n\n    function token(match) {\n      return _.merge(\n        defaultToken(match, options, indent),\n        {\n          source: link,\n          relativePath,\n          references: [...references],\n          parents: [link, ...parents],\n        }\n      );\n    }\n\n    function separator(match) {\n      return defaultSeparator(match, { indent, source: link });\n    }\n\n    const tokenizerOptions = { leaveBehind: `${WHITESPACE_GROUP}`, token, separator };\n    const linkRegExp = _.get(options, 'linkRegExp') || defaultTokenRegExp;\n    const tokenizerStream = regexpTokenizer(tokenizerOptions, linkRegExp);\n\n    tokenizerStream.pipe(resolverStream);\n\n    return duplexer({ objectMode: true }, tokenizerStream, resolverStream);\n  }\n\n  /* eslint-disable consistent-return */\n  function transform(chunk, encoding, cb) {\n    const transclusionLink = _.get(chunk, 'link');\n    const relativePath = _.get(chunk, 'relativePath') || '';\n    const parentRefs = _.get(chunk, 'references') || [];\n    const parents = _.get(chunk, 'parents') || [];\n    const indent = _.get(chunk, 'indent') || '';\n    const self = this;\n\n    function handleError(message, path, error) {\n      self.push(chunk);\n      if (!_.isUndefined(message)) self.emit('error', { message, path, error });\n      return cb();\n    }\n\n    if (!transclusionLink) return handleError();\n\n    //  Sourcemap\n    const cursor = {\n      line: _.get(chunk, 'line'),\n      column: _.get(chunk, 'column') + chunk.content.indexOf(transclusionLink),\n    };\n\n    // Parses raw transclusion link: primary.link || fallback.link reference.placeholder:reference.link ...\n    parseTransclude(transclusionLink, relativePath, source, cursor, (parseErr, primary, fallback, parsedReferences) => {\n      if (parseErr) return handleError('Link could not be parsed', transclusionLink, parseErr);\n\n      const references = _.uniq([...parsedReferences, ...parentRefs]);\n\n      // References from parent files override primary links, then to fallback if provided and no matching references\n      const link = resolveReferences(primary, fallback, parentRefs);\n\n      // NEW: support for custom resolve link function\n      const linkResolver = _.isFunction(options.resolveLink) ? options.resolveLink : resolveLink;\n\n      // Resolve link to readable stream\n      linkResolver(link, (resolveErr, input, resolvedLink, resolvedRelativePath) => {\n        if (resolveErr) return handleError('Link could not be inflated', resolvedLink, resolveErr);\n        if (_.includes(parents, resolvedLink)) return handleError('Circular dependency detected', resolvedLink);\n\n        const inflater = inflate(resolvedLink, resolvedRelativePath, references, parents, indent);\n\n        input.on('error', (inputErr) => {\n          this.emit('error', inputErr);\n          cb();\n        });\n\n        inflater.on('readable', function inputReadable() {\n          let content;\n          while ((content = this.read()) !== null) {\n            self.push(content);\n          }\n        });\n\n        inflater.on('error', (inflateErr) => {\n          this.emit('error', inflateErr);\n          cb();\n        });\n\n        inflater.on('end', () => cb());\n\n        input.pipe(inflater);\n      });\n    });\n  }\n\n  return through2.obj(transform);\n}\n"]}